#mobility
R_daily1 <- Rt_fun(theta = theta0, x = M )
#mobility
R_daily1 <- Rt_fun(theta = Ts, x = M )
#mobility
R_daily1 <- Rt_fun(theta = theta0, x = M )
#mobility
R_daily2 <- Rt_fun(theta = Ts, x = M )
Ts[J]
theta0[J]
View(R_daily1)
View(R_daily2)
res0 <- adapt_tuning(repli = repli_adapt,
within_iter = within_iter,
theta0 = theta0,
sigma = s)
res0$sigma
theta0 = res0$theta0
s = res0$sigma
#############################################################################
# for MCMC
thetas <- matrix(NA,iter,length(theta0))  # Rt's and initial conditions for each location
L <- thetas                         # store likelihoods
# L1 <- Like1(theta = theta0)
L1 <- Like1(theta = theta0)
L[1,] <- rep(L1,6)
thetas[1,] <- theta0
L1
L[1,] <- rep(L1,6)
thetas[1,] <- theta0
i=2
j=5
Ts <- theta0
J <- (j-1)*N_geo+(1:N_geo)
# propose new parameter j
if (j %in% c(1,3)){
Ts[J] <- Ts[J]*exp(s[J]*rnorm(N_geo,0,1))
}else if (j %in% c(2,4)){
Ts[J] <- Ts[J]+(s[J]*rnorm(N_geo,0,1))
}else if (j %in% c(5)){
# Ts[J] <- sample(x = 1:length(allowed_change),size = N_geo,replace = TRUE)
Ts[J] <- Ts[J]+round(s[J]*rnorm(N_geo,0,1))
}else{
Ts[J] <- Ts[J]*exp(s[J]*rnorm(1,0,1))
}
Ts[J]
theta0[J]
f <- which((Ts < prior_theta[,1]) | (Ts > prior_theta[,2]))
Ts[f] <- theta0[f]
Lint <- Like1(theta = Ts)
r <- exp(Lint-L1) * exp(-1*(Ts[N_geo*5+1]-theta0[N_geo*5+1]))
r
library(knitr)
library(Hmisc)
library(EpiEstim)
library(zoo)
library(latex2exp)
opts_chunk$set(collapse = TRUE)
opts_chunk$set(fig.path='../../../../Dropbox (SPH Imperial College)/Mobility.2.0.Save/Saved_file/FitModels/R0_beta_tD_Over/figs/', fig.keep='high',
dev=c('png'), fig.width=9, fig.height=6, cache=FALSE,
tidy=FALSE, warning=FALSE, fig.show="asis"
)
rep <- 1e2
# rep_sim <- 1e3
output <- list()
output2 <- list()
inputs<- readRDS(file=
'../../../../Dropbox (SPH Imperial College)/Mobility.2.0.Save/Saved_file/inputProcessing/Rdata/inputs.rds')
names(inputs)
data_stream <- names(inputs$M_process_mat )
# allowed_change <- as.Date(c("2020-03-02","2020-04-06",
#                             "2020-05-04","2020-06-01","2020-07-06"),
#                           format = '%Y-%m-%d')
prior_tc <- readRDS(file = paste0('../../../../Dropbox (SPH Imperial College)/Mobility.2.0.Save/Saved_file/post_epi_priorTc/','AG','_prior_tc_.rds'))
Mdata = data_stream[1]
# for (si in 2){
si=2
########################################
####inputs
D0 <- inputs$D
Mold <- inputs$M_process_mat[[Mdata]]
f_country_with_Mdata <- which(colSums(!is.na(Mold))>0)
D <- inputs$D[,c(1,1+f_country_with_Mdata)]
M1 <- inputs$M_process_mat[[Mdata]][,f_country_with_Mdata]
M <- M1/100
M[is.na(M)] <- 1
Ot <- inputs$Ot[[si]]$Ot[,f_country_with_Mdata]
W <- inputs$W[[si]]$W
H <- inputs$H
SI <- inputs$SI[[si]]$SI
delta_id <- inputs$delta_id
#
country <- names(D)[-1]
mD <- as.matrix(D[,-1])
N_geo <- ncol(D)-1
N_days <- nrow(D)
N_week <- nrow(D)/7
t_change_date <- rep(NA,N_geo)
for(i in 1:N_geo){
f <- which(prior_tc$country %in% country[i])
t_change_date[i] <- which(D$dates %in% prior_tc$tc[f])
}
# prerp MCMC
# epi
R0 <- 5
# for risk
b <- 0
o <- 1
t_change <- 3
theta0 <- c(rep(R0,N_geo),
rep(b,N_geo),
rep(R0,N_geo),
rep(b,N_geo),
t_change_date,
rep(o,N_geo))
prior_theta <- matrix(c(rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
c(rbind(t_change_date-10,t_change_date+10)),
rep(c(0,1e5),N_geo)), # over
length(theta0),2, byrow=TRUE)
# parameter names
f0 <- function(x) paste0('R0_',x)
f1 <- function(x) paste0('beta_',x)
f0b <- function(x) paste0('R02_',x)
f1b <- function(x) paste0('beta2_',x)
fx <- function(x) paste0('tc_',x)
f2 <- function(x) paste0('Over_',x)
n_t<- c(sapply(country,f0), sapply(country,f1),
sapply(country,f0b), sapply(country,f1b),
sapply(country,fx),sapply(country,f2))
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
########################################
# useful functions
# useful functions
sapply(paste0('Rscript/with_Tchange/',(list.files('Rscript/with_Tchange/'))),FUN = source)
########################################
#run MCMC
#check
# res <- MCMC_iter(iter = rep, theta0 = theta0, s = sigma)
res <- MCMC_full(iter = rep,
theta0 = theta0,
s = sigma,
repli_adapt = 10,
within_iter = rep/10)
########################################
## check convergence
print('########################################')
print(paste0('check convergence - ',Mdata,' - ',si))
Acc <- colSums(diff(res$theta)!=0)/(rep-1)
# thining
if(rep >1e3){
f <- round(seq(1,rep,length.out = 1e3))
res$theta <- res$theta[f,]
res$logL <- res$logL[f,]
}
rep <- nrow(res$theta)
# check results
plot(res$logL[,1],main=paste0('DIC ',res$DIC[1],', P ',res$DIC[2]))
layout(matrix(1:4,2,2))
for (i in 1:length(theta0)){
plot(res$theta[,i],
main = paste0(n_t[i],' - ',round(Acc[i]*100)))#,       ylim = prior_theta[i,])
}
iter = rep
theta0 = theta0
s = sigma
repli_adapt = 10
within_iter = rep/10
res0 <- adapt_tuning(repli = repli_adapt,
within_iter = within_iter,
theta0 = theta0,
sigma = s)
theta0 = res0$theta0
s = res0$sigma
#############################################################################
# for MCMC
thetas <- matrix(NA,iter,length(theta0))  # Rt's and initial conditions for each location
L <- thetas                         # store likelihoods
#############################################################################
# get the daily 'forces of infections'
# L1 <- Like1(theta = theta0)
L1 <- Like1(theta = theta0)
L[1,] <- rep(L1,6)
thetas[1,] <- theta0
#############################################################################
# sampling
for (i in 2:iter){
#print(i)
for (j in 1:6){
Ts <- theta0
J <- (j-1)*N_geo+(1:N_geo)
# propose new parameter j
if (j %in% c(1,3)){
Ts[J] <- Ts[J]*exp(s[J]*rnorm(N_geo,0,1))
}else if (j %in% c(2,4)){
Ts[J] <- Ts[J]+(s[J]*rnorm(N_geo,0,1))
}else if (j %in% c(5)){
# Ts[J] <- sample(x = 1:length(allowed_change),size = N_geo,replace = TRUE)
Ts[J] <- Ts[J]+round(s[J]*rnorm(N_geo,0,1))
}else{
Ts[J] <- Ts[J]*exp(s[J]*rnorm(1,0,1))
}
f <- which((Ts < prior_theta[,1]) | (Ts > prior_theta[,2]))
Ts[f] <- theta0[f]
Lint <- Like1(theta = Ts)
#get the ratio with previous value of parameter and correct for porposal (and, only for initial conditions, prior distribution)
if (j %in% c(1,3,6)){
r <- exp(Lint-L1)*Ts[J]/theta0[J] * exp(-1*(Ts[N_geo*5+1]-theta0[N_geo*5+1]))#
}else{
r <- exp(Lint-L1) * exp(-1*(Ts[N_geo*5+1]-theta0[N_geo*5+1]))
}
# accept or reject
if(j %in% c(1,2,3,4,5)){
for (h in 1:N_geo){
if (runif(1,0,1) <= r[h]){
theta0[J[h]] <- Ts[J[h]]  # if accept, keep new parameter value
L1[h] <- Lint[h]          # if accept, keep new lieklihood
}
}
}else{
# for (h in 1:N_geo){
r <- exp(sum(Lint)-sum(L1))*Ts[J[1]]/theta0[J[1]] * exp(-1*(Ts[N_geo*5+1]-theta0[N_geo*5+1]))
if (runif(1,0,1) <= r[1]){
theta0[J] <- Ts[J]  # if accept, keep new parameter value
L1 <- Lint          # if accept, keep new lieklihood
}
# }
}
L[i,J] <- L1    # store final likelihood
}
thetas[i,] <- theta0  # store final parameter values for this iteration
}
j=5
J <- (j-1)*N_geo+(1:N_geo)
plot(theta[,J[1]]
)
plot(thetas[,J[1]])
theta0 = res0$theta0
s
theta0
res0$sigma
J[1]
theta0 <- c(rep(R0,N_geo),
rep(b,N_geo),
rep(R0,N_geo),
rep(b,N_geo),
t_change_date,
rep(o,N_geo))
prior_theta <- matrix(c(rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
c(rbind(t_change_date-10,t_change_date+10)),
rep(c(0,1e5),N_geo)), # over
length(theta0),2, byrow=TRUE)
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
res0 <- adapt_tuning(repli = repli_adapt,
within_iter = within_iter,
theta0 = theta0,
sigma = s)
res0$sigma
sigma[(5-1)*N_geo+(1:N_geo)] <- 5
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
sigma
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
sigma[(5-1)*N_geo+(1:N_geo)] <- 5
sigma
theta0 <- c(rep(R0,N_geo),
rep(b,N_geo),
rep(R0,N_geo),
rep(b,N_geo),
t_change_date,
rep(o,N_geo))
prior_theta <- matrix(c(rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
c(rbind(t_change_date-10,t_change_date+10)),
rep(c(0,1e5),N_geo)), # over
length(theta0),2, byrow=TRUE)
# parameter names
f0 <- function(x) paste0('R0_',x)
f1 <- function(x) paste0('beta_',x)
f0b <- function(x) paste0('R02_',x)
f1b <- function(x) paste0('beta2_',x)
fx <- function(x) paste0('tc_',x)
f2 <- function(x) paste0('Over_',x)
n_t<- c(sapply(country,f0), sapply(country,f1),
sapply(country,f0b), sapply(country,f1b),
sapply(country,fx),sapply(country,f2))
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
sigma[(5-1)*N_geo+(1:N_geo)] <- 5
########################################
# useful functions
# useful functions
sapply(paste0('Rscript/with_Tchange/',(list.files('Rscript/with_Tchange/'))),FUN = source)
########################################
#run MCMC
#check
# res <- MCMC_iter(iter = rep, theta0 = theta0, s = sigma)
res <- MCMC_full(iter = rep,
theta0 = theta0,
s = sigma,
repli_adapt = 10,
within_iter = rep/10)
########################################
## check convergence
print('########################################')
print(paste0('check convergence - ',Mdata,' - ',si))
Acc <- colSums(diff(res$theta)!=0)/(rep-1)
# thining
if(rep >1e3){
f <- round(seq(1,rep,length.out = 1e3))
res$theta <- res$theta[f,]
res$logL <- res$logL[f,]
}
rep <- nrow(res$theta)
# check results
plot(res$logL[,1],main=paste0('DIC ',res$DIC[1],', P ',res$DIC[2]))
layout(matrix(1:4,2,2))
for (i in 1:length(theta0)){
plot(res$theta[,i],
main = paste0(n_t[i],' - ',round(Acc[i]*100)))#,       ylim = prior_theta[i,])
}
prior_theta
prior_theta[J,]
# for (si in 2){
si=2
########################################
####inputs
D0 <- inputs$D
Mold <- inputs$M_process_mat[[Mdata]]
f_country_with_Mdata <- which(colSums(!is.na(Mold))>0)
D <- inputs$D[,c(1,1+f_country_with_Mdata)]
M1 <- inputs$M_process_mat[[Mdata]][,f_country_with_Mdata]
M <- M1/100
M[is.na(M)] <- 1
Ot <- inputs$Ot[[si]]$Ot[,f_country_with_Mdata]
W <- inputs$W[[si]]$W
H <- inputs$H
SI <- inputs$SI[[si]]$SI
delta_id <- inputs$delta_id
#
country <- names(D)[-1]
mD <- as.matrix(D[,-1])
N_geo <- ncol(D)-1
N_days <- nrow(D)
N_week <- nrow(D)/7
t_change_date <- rep(NA,N_geo)
for(i in 1:N_geo){
f <- which(prior_tc$country %in% country[i])
t_change_date[i] <- which(D$dates %in% prior_tc$tc[f])
}
# prerp MCMC
# epi
R0 <- 5
# for risk
b <- 0
o <- 1
t_change <- 3
theta0 <- c(rep(R0,N_geo),
rep(b,N_geo),
rep(R0,N_geo),
rep(b,N_geo),
t_change_date,
rep(o,N_geo))
prior_theta <- matrix(c(rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
c(rbind(t_change_date-10,t_change_date+10)),
rep(c(0,1e5),N_geo)), # over
length(theta0),2, byrow=TRUE)
# parameter names
f0 <- function(x) paste0('R0_',x)
f1 <- function(x) paste0('beta_',x)
f0b <- function(x) paste0('R02_',x)
f1b <- function(x) paste0('beta2_',x)
fx <- function(x) paste0('tc_',x)
f2 <- function(x) paste0('Over_',x)
n_t<- c(sapply(country,f0), sapply(country,f1),
sapply(country,f0b), sapply(country,f1b),
sapply(country,fx),sapply(country,f2))
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
sigma[(5-1)*N_geo+(1:N_geo)] <- 1
########################################
# useful functions
# useful functions
sapply(paste0('Rscript/with_Tchange/',(list.files('Rscript/with_Tchange/'))),FUN = source)
########################################
#run MCMC
#check
# res <- MCMC_iter(iter = rep, theta0 = theta0, s = sigma)
res <- MCMC_full(iter = rep,
theta0 = theta0,
s = sigma,
repli_adapt = 10,
within_iter = rep/10)
########################################
## check convergence
print('########################################')
print(paste0('check convergence - ',Mdata,' - ',si))
Acc <- colSums(diff(res$theta)!=0)/(rep-1)
# thining
if(rep >1e3){
f <- round(seq(1,rep,length.out = 1e3))
res$theta <- res$theta[f,]
res$logL <- res$logL[f,]
}
rep <- nrow(res$theta)
# check results
plot(res$logL[,1],main=paste0('DIC ',res$DIC[1],', P ',res$DIC[2]))
# for (si in 2){
si=2
########################################
####inputs
D0 <- inputs$D
Mold <- inputs$M_process_mat[[Mdata]]
f_country_with_Mdata <- which(colSums(!is.na(Mold))>0)
D <- inputs$D[,c(1,1+f_country_with_Mdata)]
M1 <- inputs$M_process_mat[[Mdata]][,f_country_with_Mdata]
M <- M1/100
M[is.na(M)] <- 1
Ot <- inputs$Ot[[si]]$Ot[,f_country_with_Mdata]
W <- inputs$W[[si]]$W
H <- inputs$H
SI <- inputs$SI[[si]]$SI
delta_id <- inputs$delta_id
#
country <- names(D)[-1]
mD <- as.matrix(D[,-1])
N_geo <- ncol(D)-1
N_days <- nrow(D)
N_week <- nrow(D)/7
t_change_date <- rep(NA,N_geo)
for(i in 1:N_geo){
f <- which(prior_tc$country %in% country[i])
t_change_date[i] <- which(D$dates %in% prior_tc$tc[f])
}
# prerp MCMC
# epi
R0 <- 5
# for risk
b <- 0
o <- 1
t_change <- 3
theta0 <- c(rep(R0,N_geo),
rep(b,N_geo),
rep(R0,N_geo),
rep(b,N_geo),
t_change_date,
rep(o,N_geo))
prior_theta <- matrix(c(rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
rep(c(0,5),N_geo),
rep(c(-1e2,1e2),N_geo),
c(rbind(t_change_date-10,t_change_date+10)),
rep(c(0,1e5),N_geo)), # over
length(theta0),2, byrow=TRUE)
# parameter names
f0 <- function(x) paste0('R0_',x)
f1 <- function(x) paste0('beta_',x)
f0b <- function(x) paste0('R02_',x)
f1b <- function(x) paste0('beta2_',x)
fx <- function(x) paste0('tc_',x)
f2 <- function(x) paste0('Over_',x)
n_t<- c(sapply(country,f0), sapply(country,f1),
sapply(country,f0b), sapply(country,f1b),
sapply(country,fx),sapply(country,f2))
# sd dev for proposal
sigma <- rep(1e-1,length(theta0))
sigma[(5-1)*N_geo+(1:N_geo)] <- 1
########################################
# useful functions
# useful functions
sapply(paste0('Rscript/with_Tchange/',(list.files('Rscript/with_Tchange/'))),FUN = source)
########################################
#run MCMC
#check
# res <- MCMC_iter(iter = rep, theta0 = theta0, s = sigma)
res <- MCMC_full(iter = rep,
theta0 = theta0,
s = sigma,
repli_adapt = 10,
within_iter = rep/10)
########################################
## check convergence
print('########################################')
print(paste0('check convergence - ',Mdata,' - ',si))
Acc <- colSums(diff(res$theta)!=0)/(rep-1)
# thining
if(rep >1e3){
f <- round(seq(1,rep,length.out = 1e3))
res$theta <- res$theta[f,]
res$logL <- res$logL[f,]
}
rep <- nrow(res$theta)
# check results
plot(res$logL[,1],main=paste0('DIC ',res$DIC[1],', P ',res$DIC[2]))
layout(matrix(1:4,2,2))
for (i in 1:length(theta0)){
plot(res$theta[,i],
main = paste0(n_t[i],' - ',round(Acc[i]*100)))#,       ylim = prior_theta[i,])
}
